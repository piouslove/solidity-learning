# 智能合约需要注意的要点

## 无法指定的区块
交易不能保证在下一个区块或任何未来的指定区块中发生，因为矿工不能识别交易的提交者就需要打包交易。包括函数调用、交易以及创建合约等操作都无法指定区块。

## “payload”
payload就是与交易一起发送的 `.abi` 文件字节码“数据”。

## 是否有可用的反编译器？
Solidity没有反编译器。这在某种程度上原则上是可能的，但是例如变量名称将会丢失，并且需要付出巨大的努力才能使其看起来类似于原始源代码。
字节码可以反编译为操作码，这是由几个区块链探查器提供的服务。
所以如果要由第三方使用，则块上的合同应该发布其原始源代码。

## 创建可以杀死和归还资金的合同
注意杀死合同听起来好像是一个好主意，因为“清理”总是很好，但如上所述，它并没有真正的清理。此外，如果以ether被发送到删除的合同，ether就相当于永远丢失。
所以如果要停用合同，最好通过 `disable` 使所有函数抛出内部状态来禁用它们。这将使得无法使用合约，并且发送到合约的以太币将自动退回。

## solidity不能表示的数据类型
`double` 和 `float` 暂时不被支持。

## 是否可能像这样在线初始化数组： `string[] myarray = ["a", "b"];`
可以这样做，但是应该注意的是，目前这种方法只适用于静态大小的存储器阵列。你甚至可以在return语句中创建一个内联的内存数组。例如：
```
pragma solidity ^0.4.0;

contract C {
    function f() returns (uint8[5]) {
        string[4] memory adaArr = ["This", "is", "an", "array"];
        return ([1, 2, 3, 4, 5]);
    }
}
```
